---
layout: post
title: "Solidity Lesson 1: 좀비 공장 만들기"
categories: [Cryptography & Blockchain]
tags: [Solidity, Ethereum, Smart Contracts]
last_modified_at: 2024-07-03
---

```javascript
pragma solidity ^0.4.19;

contract HelloWorld {

}
```
1. 컨트랙트  
컨트랙트: 이더리움 애플리케이션은 구성 요소  
모든 변수와 함수는 어느 한 컨트랙트에 속해 있음  

2. Version Pragma  
모든 솔라디티 소스 코드는 solidity 버전 명시로 시작  

```javascript
struct Person {
  uint age;
  string name;
}

// 2개의 원소를 담을 수 있는 고정 길이의 배열:
uint[2] fixedArray;
// 또다른 고정 배열로 5개의 스트링을 담을 수 있다:
string[5] stringArray;
// 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있다:
uint[] dynamicArray;

Person[] public people;

function eatHamburgers(string _name, uint _amount) {

}
```
3. 상태 변수 & 정수  
상태 변수: 컨트랙트 저장소에 영구 저장 -> 블록체인에 기록  

4. 구조체, 배열, 함수 선언  
위 예제만 남겼음  
public은 다른 배열들이 해당 배열을 읽을 수 있음(쓰기는 X)  
컨트랙트에 공개 데이터 저장 시 유용  

```javascript
uint[] numbers;

function _addToArray(uint _number) private {
  numbers.push(_number);
}

function _multiply(uint a, uint b) private pure returns (uint) {
  return a * b;
}
```
5. private  
기본적으로 함수는 private 선언 -> 함수명 앞에 언더바 넣는 것이 관례  
공개할 함수만 public  

6. 함수 제어자  
함수의 상태를 변경하지 않고 보기만 하는 경우 -> view  
어떤 데이터에도 접근하지 않는 경우 -> pure  

7. keccak256  
이더리움이 갖고 있는 SHA3의 한 버전 해시 함수  

```javascript
// 이벤트를 선언한다
event IntegersAdded(uint x, uint y, uint result);

function add(uint _x, uint _y) public {
  uint result = _x + _y;
  // 이벤트를 실행하여 앱에게 add 함수가 실행되었음을 알린다:
  IntegersAdded(_x, _y, result);
  return result;
}

YourContract.IntegersAdded(function(error, result) {
  // 결과와 관련된 행동을 취한다
});
```
8. 이벤트  
이벤트: 어떤 액션이 생겼을 때 이벤트 발동 -> 컨트랙트가 또 하나의 행동을 취함  

```javascript
// 여기에 우리가 만든 컨트랙트에 접근하는 방법을 제시한다:
var abi = /* abi generated by the compiler */
var ZombieFactoryContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// `ZombieFactory`는 우리 컨트랙트의 public 함수와 이벤트에 접근할 수 있다.

// 일종의 이벤트 리스너가 텍스트 입력값을 취한다:
$("#ourButton").click(function(e) {
  var name = $("#nameInput").val()
  // 우리 컨트랙트의 `createRandomZombie`함수를 호출한다:
  ZombieFactory.createRandomZombie(name)
})

// `NewZombie` 이벤트가 발생하면 사용자 인터페이스를 업데이트한다
var event = ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  generateZombie(result.zombieId, result.name, result.dna)
})

// 좀비 DNA 값을 받아서 이미지를 업데이트한다
function generateZombie(id, name, dna) {
  let dnaStr = String(dna)
  // DNA 값이 16자리 수보다 작은 경우 앞 자리를 0으로 채운다
  while (dnaStr.length < 16)
    dnaStr = "0" + dnaStr

  let zombieDetails = {
    // 첫 2자리는 머리의 타입을 결정한다. 머리 타입에는 7가지가 있다. 그래서 모듈로(%) 7 연산을 하여
    // 0에서 6 중 하나의 값을 얻고 여기에 1을 더해서 1에서 7까지의 숫자를 만든다. 
    // 이를 기초로 "head1.png"에서 "head7.png" 중 하나의 이미지를 불러온다:
    headChoice: dnaStr.substring(0, 2) % 7 + 1,
    // 두번째 2자리는 눈 모양을 결정한다. 눈 모양에는 11가지가 있다:
    eyeChoice: dnaStr.substring(2, 4) % 11 + 1,
    // 셔츠 타입에는 6가지가 있다:
    shirtChoice: dnaStr.substring(4, 6) % 6 + 1,
    // 마지막 6자리는 색깔을 결정하며, 360도(degree)까지 지원하는 CSS의 "filter: hue-rotate"를 이용하여 아래와 같이 업데이트된다:
    skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360),
    eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360),
    clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360),
    zombieName: name,
    zombieDescription: "A Level 1 CryptoZombie",
  }
  return zombieDetails
}
```
9. Web3.js  
이더리움이 갖고 있는 자바스크립트 라이브러리  
컨트랙트와 사용자의 자바스크립트 코드가 서로 상호작용  
자바스크립트에서 컨트랙트의 public, event 접근 가능  

[https://share.cryptozombies.io/ko/lesson/1/share/](https://share.cryptozombies.io/ko/lesson/1/share/)  
lesson 1 클리어~