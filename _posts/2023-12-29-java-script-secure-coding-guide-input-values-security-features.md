```markdown
---
layout: post
title: "자바스크립트 시큐어코딩 가이드: 입력값,보안기능"
categories: [SWING, Writeup, Self-study]
tags: []
last_modified_at: 2023-12-29
---

웹 서비스의 특이점
----------------

웹은 브라우저 환경 위에서 동작  
인터페이스와 서버 사이 간극(이 사이 신뢰할 수 없는 구간을 지남), 사용자 많음  
코드의 많은 부분이 노출됨  

웹 서비스의 발전 -> 클라이언트 사이드 위협 증가  
이에 따라 개발 단계부터 안전한 보안성 필요  

**자바스크립트:** 대화형 웹페이지 개발을 위한 프로그래밍 언어. 클라이언트나 서버 사이드, 모바일 앱, 임베디드 프로그램까지 개발 가능  
자바스크립트 엔진에서 발견된 많은 취약점 존재  

소프트웨어 개발 생명주기(SDLC)의 단계별로 요구되는 보안활동 수행  

1. 입력데이터 검증 및 표현
----------------

프로그램에서 검색이나 로그인 등 입력값에 대한 다양한 취약점 존재  
검증 누락, 부적절한 검증, 잘못된 형식 지정, 일관되지 않은 언어셋 사용  

- SQL injection : 악의적 동적쿼리 실행하는 공격  
자바스크립트와 DB 간의 상호작용 방식  
1. 데이터베이스 드라이버: 클라이언트와 커넥터 사용하여 직접 상호작용 **SQL 인젝션 취약점**  
2. 쿼리 빌더: DB 클라이언트보다 한 단계 높은 계층에서 동작, 자바스크립트 코드로 쿼리 데이터 생성 -> 데이터베이스와 상호작용  
3. ORM: 데이터베이스를 객체 형식으로 다룰 수 있게 해주는 툴킷 **원시 쿼리 기능 등으로 SQL 인젝션 취약점**  

쿼리 빌더 사용으로 sql 인젝션 방어 가능  
화이트 리스트 기반 방식 필요(허용된 값만 넘기기)  
*특수문자 필요나 복잡한 동적 쿼리의 경우 필터링 규칙 변형 필요*  

if 공격에 사용되는 문자를 필터링할 수 없다면?  
데이터베이스 드라이버 사용 or ORM에서 지원하는 원시 쿼리기능 사용  
대신 인자화된 쿼리를 통해 외부 입력값을 바인딩해서 사용  
*인자화된 쿼리? 입력값 -> DB API를 통하여 쿼리 내에 사용자 입력값 구성(템플릿에 값 삽입하는 꼴)*  
예제)  
데이터베이스 드라이버 사용  
ORM 사용  

- 코드 삽입(server side)  
자바스크립트에서 코드 인젝션을 유발할 수 있는 함수: eval(), setTimeout(), setInterval()  

위 함수(동적 코드를 실행할 수 있는 함수) 사용 X  
if 필요하다면?  
화이트리스트 기반 검증 혹은 데이터와 명령어 구분지어 처리하는 로직 구현  
예제)  

- 경로 조작 및 자원 인젝션(client side): 시스템이 보호하는 자원에 임의로 접근할 수 있는 취약점  
클라이언트측 자바스크립트에서 외부 입력값 기반으로 하는 호스트 시스템의 프로세스 제어, 파이프 상호작용, 소켓 연결 등 특별한 경우에만 사용, NodJS 서버 프로그램의 경우 fs 및 socket.io 라이브러리를 통해 제어 가능  

외부 입력값을 자원(파일, 소켓의 포트)의 식별자로 사용하는 경우 화이트리스트 적용  
특히 파일명일 때 경로순회 필터링 필요  
예제)  
경로 조작 예제  
자원 삽입 예제  

- XSS: 웹사이트에 악성코드 삽입  
1. Reflective XSS: 사용자의 HTTP 요청에 공격 코드 삽입 -> 서버에 그대로 반사 실행, 사용자가 공격자가 만든 서버로 데이터 전송하도록 유도  
2. Persistent XSS: 신뢰할 수 없는 사용자 입력이 서버로 저장 -> 다른 사용자에게 전달, 게시글 및 댓글이나 방문자 로그 기능에서 발생  
3. DOM XSS: 자바스크립트의 검증 로직 무효화, DOM 또는 문서 개체 모델 수정하여 브라우저와 독립적 공격 실행  

자바스크립트는 클라이언트측, 서버측 모두 개발 가능하므로 양쪽 모두 XSS 공격 예방 필요  
공격포인트 지점: 서버가 생성한 HTML 응답 데이터 내에 신뢰할 수 없는 데이터 포함된 경우 혹은 자바스크립트 호출을 통해 DOM을 업데이트하는데 입력값이 전달된 경우  

스크립트가 삽입되지 못하게 문자열 치환함수로 특수문자 변환  
자바스크립트에서 제공하는 escape 기능으로 문자열 변환 (지금은 deprecated로 권장 x)  
대신 encodeURI() 혹은 encodeURIComponent()  
HTML 태그 허용에서는 화이트리스트 제공  
클라이언트측에서 1차 검증, 서버측에서 2차 검증, 서버로부터 가져온 데이터 클라이언트측에서 보여줄 때도 문자열 필터링  
예제)  
클라이언트측 Vanilla.js  
클라이언트측 ReactJS  
서버측 ExpressJS  

- 운영체제 명령어 삽입: 입력값에 운영체제 명령어 구성되어 실행시키는 공격  
NodeJS에서 child_process 라이브러리를 통해 코드 내부에서 시스템 명령어 실행 가능  

멀티라인 및 리다이렉트 문자 등 필터링, 파일명과 옵션 제한 -> 인자로만 사용할 수 있도록 제공  
명령어가 필요하면 그에 따른 값들만 미리 지정  
예제)  

- 위험한 형식 파일 업로드: 스크립트 파일을 업로드 가능하고 웹을 통해 실행시킬 수 있을 때 발생하는 취약점  
NodeJS에서 업로드를 성공했다고 파일 실행 등 웹쉘 공격으로 이어지기는 어려움  

파일 형식 화이트리스트  
파일의 Content-Type 확인  
크기 및 개수 제한  
업로드 된 파일 웹 루트 폴더 외부에 저장 -> 공격자가 URL로 실행할 수 없음  
파일 이름 무작위로 변경 후 저장  
파일 저장할 때 최소 권한만 부여하고 실행 권한은 삭제 요망  

- 신뢰되지 않은 URL주소로 자동접속 연결: 피싱 위험  
자동 접속하는 서버 프로그램  

리다이렉션을 허용하는 모든 URL을 서버측 화이트리스트로 관리  
if 화이트리스트로 관리가 힘들다면?  
모든 리다이렉션에서 프로토콜과 host 정보가 들어가지 않는 상대 URL 사용 및 검증  
절대 URL -> 정상 서비스 중인 URL로 시작하는지 확인  
예제)  

- 부적절한 XML 외부 개체 참조  
XML 문서에 DTD 포함 가능  
NodeJS에서 내장 XML 파싱 엔진 지원 X, 라이브러리 사용 시 외부 엔티티 파싱 기능은 비활성화  

로컬 정적 DTD 사용  
외부에서 전송된 XML 문서의 DTD는 비활성화  
if 비활성화 할 수 없는 경우  
외부 엔티티 및 외부 문서 유형 선언을 각 파서에 맞는 고유한 방식으로 비활성화  
외부 라이브러리 사용 -> 외부 엔티티 구문 분석 기능 제공하는지 확인 -> 해당 기능 비활성화  
lxml의 경우, resolve_entities 옵션 비활성화  
외부 문서 조회는 no_network 활성화  
예제)  

- XML 삽입: 입력값이 XQuery 또는 XPath 생성  
XQuery 혹은 XPath 쿼리에 사용되는 외부 입력 데이터에 대하여 특수문자 및 쿼리 예약어 필터링  
인자화된 쿼리문 지원하는 XQuery 사용  
예제)  

- LDAP 삽입: LDAP 실행 시 공격자 임의로 변경 가능  
자바스크립트에는 LDAP 데이터 처리를 위한 다양한 패키지 존재, ldapjs가 대중적  

인코딩 함수로 변수 이스케이프 처리  
화이트리스트 기반 검증  
민감한 정보 필드는 인덱싱  
LDAP 바인딩 계정에 할당된 권한 최소화  
예제)  

- CSRF: 사용자 권한으로 공격자의 행위 요청  
사용자로부터 받은 요청이 사용자가 의도한대로 작성되고 전송된 것인지 확인하지 않았을 때 발생  
정상/비정상 요청을 구분하지 못함  
특히 관리자 권한을 가지는 경우 위험  
자바스크립트 ExpressJS에서는 CSRF 토큰 기능 지원 X, csurf 같은 패키지로 토큰 적용(최근엔 deprecated)  
토큰 값 세션 저장과 토큰 헤더 키 추가 옵션 설정  

세션 별로 CSRF 토큰 생성, hidden으로 값 전달 -> 유효성 검사  
예제)  

- 서버 사이드 요청 위조: 입력값이 내부 서버간의 요청 사용  
외부에 노출된 웹 서버가 취약한 애플리케이션을 포함할 때  

입력값을 다른 시스템의 서비스 호출에 사용하는 경우, 화이트리스트  
if 무작위의 URL을 받아야 한다면?  
내부 URL을 블랙리스트 지정  
내부 네트워크에 있더라도 기기 인증, 접근권한 확인  
예제)  

- 보안 기능 결정에 사용되는 입력값  
응용 프로그램이 외부 입력값에 대한 신뢰를 전제로 보호 메커니즘 사용 시 발생  
쿠키, 환경변수, 히든필드 같은 입력값이 조작될 수 없다고 가정하지만 다양한 방법 존재  
인증, 인가가 위 입력값들로 의존하여 수행되면 취약점 발생  

민감한 데이터(세션 정보)는 서버 저장  
보안확인 절차도 서버 실행  
입력값이 응용 프로그램 내부로 들어올 수 있는 지점 확인  
보안 메커니즘에 쓰이는 입력값 식별 -> 의존성 제거  
예제)  

2. 보안기능
----------------

인증, 접근제어, 기밀성, 암호화 등을 올바르게 구현해야함  
그렇지 않을 때 중요기능 허용, 부적절한 인가 등 취약점 발생  

- 적절한 인증 없는 중요 기능 허용  
서버측에서 NodeJS에서 제공하는 기본 기능으로 사용자 인증 기능 구현  
혹은 ExpressJS나 nest.js 서버 프레임워크에서 제공 기능 사용  
클라이언트측에서도 라이브러리를 이용하여 인증 기능 구현 가능  
but 서버측 인증 지원이 훨씬 중요  

클라이언트 보안 검사를 우회하여 서버 접근 못하도록 설계  
중요 정보는 재인증  
안전하다고 검증된 라이브러리나 프레임워크 사용  
예제)  

- 부적절한 인가: 접근제어 처리 오류  
접근 가능한 실행 경로를 통해 정보 유출 가능  

분리 개발 필요  
attack surface 최소화, ACL 관리  
예제)  

- 중요한 자원에 대한 잘못된 권한 설정  
보안 소스에 대해 읽기 또는 수정 권한 허가 시, 자원 사용  
NodeJS에서는 fs.chmodSync 함수로 악용 가능  

설정 파일, 실행 파일, 라이브러리 등은 관리자에 의해서만 접근  
예제)  

- 취약한 암호화 알고리즘 사용  
설정 파일에 저장된 패스워드 보호 -> 인코딩 함수 사용  

3TDEA, AES, SEED 암호 알고리즘 사용  
예제)  

- 암호화되지 않은 중요정보  
개인정보, 인증정보, 금융정보 등 많은 정보 보호 필요  

통신채널 전송, 정보 저장에는 암호화 과정 필요  
읽고 쓸 때는 권한인증  
SSL, HTTPS 보안 채널 사용  
예제)  
중요정보 평문저장  
중요정보 평문전송  

- 하드코드된 중요정보  
하드코드된 패스워드를 이용해 내부 인증이나 외부 컴포넌트와 통신 시, 관리자 정보가 노출될 수 있음  
하드코드된 암호화 키 사용 -> 암호화된 정보 유출 가능성 up  

패스워드는 암호화 후 별도 파일에 저장  
상수가 아닌 암호화 키 사용  
암호화 키를 주석으로 달거나 저장하지 않는다.(상수 형태로)  
예제)  

- 충분하지 않은 키 길이 사용  
RSA는 적어도 2048비트 이상 키  
대칭 암호화 알고리즘은 적어도 보안 강도 112비트 이상 지원하도록  
예제)  

- 적절하지 않은 난수 값 사용  
NodeJS 엔진에서 crypto.getRandomBytes 사용  
바이트 숫자 변환 X  
브라우저에서 RandomSource.getRandomValues 사용  
예제)  

- 취약한 패스워드 허용  
패스워드 선택 및 이용 안내서  

패스워드 생성 시 강한 조건 검증 적용  
예제)  

- 부적절한 전자서명 확인  
클라이언트와 서버 사이 데이터 전송, 파일 다운로드 시 발생 가능  
예제)  

- 부적절한 인증서 유효성 검증  
공격자가 호스트와 클라이언트 사이 통신 구간을 가로채, 신뢰하는 엔티티처럼 속일 수 있다  

인증서 유효성 검사, 언어에서 제공하지 않으면 암호화 패키지를 이용하여 별도의 검증 코드 마련  
예제)  

- 사용자 하드디스크에 저장되는 쿠키를 통한 정보 노출  
쿠키는 메모리에 상주 but 개발자가 임의로 쿠키를 지속할 시, 디스크에 기록  
영속적인 쿠키에 중요정보가 저장된다면 위험  

쿠키의 만료시간은 세션 지속 시간을 고려하여 설정(최소한으로)  
영속적인 쿠키에는 사용자 권한 등급, 세션 ID 정보 포함 X  
예제)  

- 주석문 안에 포함된 시스템 주요정보  

- 솔트 없이 일방향 해쉬 함수 사용  
솔트 없이 일방향 해쉬 함수 -> 레인보우 테이블로 해쉬값 알아낼 수 있음  
NodeJS에서 crypto 패키지로 해쉬값 생성 및 솔트 생성 가능  

중요 정보는 일방향 해쉬 함수로 저장, 솔트값은 사용자별로 유일하게 생성, 솔트값 별도 저장 필요  
예제)  

- 무결성 검사없는 코드 다운로드  
파일 무결성 검사 없이 실행 -> 호스트 서버 변조, DNS 스푸핑 등으로 악성코드 실행 가능해짐  

DNS lookup 수행, 코드 전송 시 암호화, 최소 권한으로 실행  
인증서 혹은 해쉬값 검사 -> 변조되지 않았는지 확인  
예제)  

- 반복된 인증시도 제한 기능 부재  
무차별 대입 공격 방지  
안전한 서버 구축이 우선(클라이언트측보다)  

인증시도 횟수 제한  
CAPTCHA, Two-Factor  
```