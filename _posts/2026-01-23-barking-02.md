---
layout: post
title: "바킹독의 실전 알고리즘 : STL과 함수 인자, 표준 입출력"
categories: [Algorithm]
tags: [coding]
last_modified_at: 2026-01-23
---

# STL과 함수 인자 

```cpp 
void func(int a){
    a=5;
}

int main(void){
    int t=0;
    func(t);
    cout<<t;
}
```

```cpp 
void func(int arr[]){
    arr[0]=10;
}

int main(void){
    int arr[3]={1,2,3};
    func(arr);
    cout<<arr[0];
}
```

```cpp
struct pt{
    int x,y;
};

void func(pt a){
    a.x=10;
}

int main(void){
    pt tmp={0,0};
    func(tmp);
    cout<<tmp.x;
}
```

3번째 구조체도 변수 넘겨주는 거랑 같게 이해하면 됨 -> 복사

## call 방법 

1. call by value -> 안 바뀜, 공간 하나 더 생김 
2. call by address -> 바뀜 (배열)
3. call by reference -> 바뀜 (구조체)

```cpp 
void swap1(int a, int b);
void swap2(int* a, int* b); //pointer 
void swap3(int& a, int& b); //referencer 
```

swap1은 그냥 변수 call by value 
swap2는 주소 전달 
swap3는 참조 (넘길 때는 변수 넘기면 됨)

```cpp
vector<int> v(100);
v[20]=10;
v[60]=-2;
```

```cpp 
void func1(vector<int> v){
    v[10]=7; //여기에서 값을 바꿨다고
}

int main(void){
    vector<int> v(100);
    func1(v);
    cout << v[10]; //여기서 바뀌진 않음 
}
```

STL을 함수 인자로 넘길 땐 어떨까.. 는 그냥 call by value 
call by value는 복사를 하니까 원소마다 다 참조 -> O(n) 

```cpp
bool cmp1 (vector<int> v1, vector<int> v2, int idx){
    return v1[idx] > v2[idx];
}

bool cmp2 (vector<int>& v1, vector<int>& v2, int idx){
    return v1[idx] > v2[idx]; //-> 이건 참조만 하니까 시간복잡도 O(1)
}
```

유의하자~ 

# 표준 입출력 

```cpp 
int main(void){
    string s="6kitty";
    printf("s is %s\n",s);
}
```

```cpp 
int main(void){
    char a[10];
    printf("input: ");
    scanf("%s",a);
    string s(a);
    printf("a is %s\n",a);
    printf("s is %s\n",s.c_str());
}
```

scanf/printf에서는 C++ string 처리가 안되다. -> 개귀찮으니까 그냥 cin/cout 쓰자 

아 그리고 공백 포함은 그냥 받으면 안된다 

```cpp 
// 1. scanf 
char a[10];
scanf("%[^\n]", a);

// 2. getline 
string s;
getline(cin,s);
cout<<s;
```

getline 쓸 때는 string형만 올 수 있다는 걸 유념하자. 
cin/cout에서 주의해야할 것이 하나 더 있다. 입출력으로 인한 시간초과를 막기 위해 `ios::sync_with_stdio(0)`, `cin.ie(0)` 명령을 실행해줘야 한다. 

```cpp 
int main(void){
    ios::sync_with_stdio(0);
    cout<<"1111\n";
    printf("1111\n")
}
```

C++ stream과 C stream은 동기화되어 있다. 그런데 내가 cin/cout만 사용할 것이라면 두 동기화하는 시간이 필요 없어지기에 ios::sync_with_stdio(0)로 싱크를 굳이 하지 않는다. 

대신 cout, printf를 섞어쓰면 안됨 -> 오류가 나는 건 아니고 순서가 꼬인다. 

cin을 위해서는 `cin.tie(0)`가 필요하다. 문자를 입력하면 입력 버퍼에 모았다가 변수로 넘겨준다. 즉각적으로 메모리에 담기는 것이 아닌 버퍼라는 중간 매개체가 있다. 입출력이 같은 버퍼를 쓰고 있기 때문에 순서가 꼬일 수 있다. 때문에 cin 명령 수행 전에 cout 버퍼를 지워야 한다. 그렇지만 저지 채점할 때는 단순 출력 글자로만 채점하기 때문에 굳이 순서 꼬이지 않게 전처리 하지 않아도 된다. -> 굳이 cout 버퍼를 비우는 수고를 할 필요가 없다. 

그리고 **endl** 쓰지 말아야 한다. -> 시간 소모가 꽤 되나 봄 

