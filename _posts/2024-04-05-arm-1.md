---
layout: post
title: "ARM 1"
categories: [System Hacking]
tags: [ARM, Embedded, Thumb, Registers, CPSR, Procedure Call]
last_modified_at: 2024-04-05
---

ARM은 mobile/embedded 맞춤.. 초기 임베디드 시장은 32bit를 지원하는 ARM이 아닌 16bit가 대세라

ARM을 반쪽으로 만든 Thumb 존재..

| Thumb mode  | ARM mode  |
|-------------|-----------|
| 레지스터 R0~r15<br/>기계어 2bytes | 레지스터 R0~R7<br/>기계어 4bytes<br/><br/>해당 모드 간 전환 자유로움<br/>x로 끝나는 분기문 명령으로 전환 |

이걸 리버싱 할 때도 유념해야 하는듯  

1. 레지스터  

![Registers](https://blog.kakaocdn.net/dna/cgmAoy/btsGo6dGf8a/AAAAAAAAAAAAAAAAAAAAALJZ29cjyHMhamw-BREy2khN4rLzbuxXGLjm6NVVjQFa/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=gfXj%2FwTFo0P5AX9euIlNH7KK9V8%3D)

범용  
- r0~r3 : 인자, 반환값 저장 / return은 r0으로..  
이 레지스터를 넘어가면 stack으로..  
- r4~r11(r9 제외) : general purpose register  
- r11 : base pointer (amd에서 rbp,ebp 역할)  
- r13 : sp  
- r14 : link register.  
* link register: 함수 call 뒤에 return 될 위치 저장, ret 역할  
- r15: pc, 실행되는 code 위치 저장  

접은 글은 LR에 대하여..  
스택에 RET 저장이 아니라 LR에 따로 레지스터에 주소를 남겨줘서 ARM bof는 경우가 좀 다른듯  
1. lr을 스택에 저장하거나  
2. 다른 함수 stack frame을 덮을 수 있거나  
보통은 1 경우라고 함  

상태, mode 전환 시 이용  
fps  
cpsr  

2. Passing Arguments via Registers  

![Passing Arguments](https://blog.kakaocdn.net/dna/bQNqLl/btsGnZsSQ7P/AAAAAAAAAAAAAAAAAAAAAFzgaFHa5juhjZ5F5ntkVmNjixNv6F7DqoLRODwj8itz/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=tPWM%2B0appuw9d%2FqCmrHQDrF5VRA%3D)

Procedure Call //arm에서는 subroutine을 procedure이라고 더 많이 부르나..  
```shell
BL label ; LR = 이 다음 instruction addr 
	 ; PC = label 
         
BX LR	 ; PC = LR
```
이참에 branch 정리하고 가자  
- b: branch, 상대 주소 기반 점프  
- bx: branch and exchange, 레지스터 기반 절대주소  
- bl: branch with link, 주소 점프(오프셋) + lr에 RET 저장  
- blx: branch with link and exchange, 레지스터 점프 + lr에 RET 저장  

하위 두 개가 RET 저장되니까 call에 많이 불리지 않을까....  
위 접은글 보면 bl을 통해 LR 설정..  
컴파일러는 label을 memory address로 translate..  

BL은 caller, callee에서 BX  
인자는 callee에서 깔아주는듯  

![Arguments](https://blog.kakaocdn.net/dna/buVStK/btsGpKhfRoY/AAAAAAAAAAAAAAAAAAAAAD_wZ7iKyG1n9cR7bax8hnJYx4eK0prYsEzEQnHmuetc/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=hhPkDYvfNpBJ3EBUSKFwNQZrn1Y%3D)

R0부터 first argument 넣음  
return은 r0으로 넣고 bx..  

stack에 넣을 때는.. [sp,#0] 이런 식으로 넣는듯  

ARM 명령은 conditional execution..  
해당 conditional execution은 CPSR state에 따라 instruction 실행하는 것을 말함  
```shell
ADDEQ r1,r2,r3
```
위 예시처럼 add 뒤에 EQ가 붙었다. 이 명령은 CPSR 30번째 비트 Z를 확인하고 이값이 1인 경우만 실행한다고 한다.  
//CPSR 레지스터를 더 자세히.. 파야 할듯  

CPSR(Current Program Status Register)  

![CPSR](https://blog.kakaocdn.net/dna/eAF25w/btsGo50Jiv3/AAAAAAAAAAAAAAAAAAAAAMfE3XC_lP4ivnuYjQigVDslp544wmjMDrAT12NFv5wK/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=XFX8g58lLQNJxWKHKH%2FQkOVUMQ8%3D)

여기에는 ALU status flags 있음 -> instruction 결과에 따라 update  
맨 앞 N,Z,C,V를 condition code flag라고 함..  
- N: 음수  
- Z: 0  
- C: arry 올림  
- V: oVerflowed  

이부분의 값을 참조하여 조건부 명령 가능 (if문처럼..)  

| Code  | Suffix | Description | Flags tested |
|-------|--------|-------------|--------------|
| 0000  | EQ     | Equal       | Z=1          |
| 0001  | NE     | Not Equal   | Z=0          |
| 0010  | CS     | Unsigned higher or same | C=1          |
| 0011  | CC     | Unsigned lower | C=0          |
| 0100  | MI     | Minus (negative) | N=1          |
| 0101  | PL     | Positive or Zero | N=0          |
| 0110  | VS     | Overflow    | V=1          |
| 0111  | VC     | No overflow  | V=0          |
| 1000  | HI     | Unsigned higher | C=1 & Z=0   |
| 1001  | LS     | Unsigned lower or same | C=0 or Z=1 |
| 1010  | GE     | Greater or Equal | N=V        |
| 1011  | LT     | Less than   | N!=V         |
| 1100  | GT     | Greater than | Z=0 & N=V   |
| 1101  | LE     | Less than or equal | Z=1 or N=!V |
| 1110  | AL     | Always      |              |

LDR/STR  
메모리 참조 가능한 명령어  
1. LDR/STR with offsets  
2. LDR with labels  