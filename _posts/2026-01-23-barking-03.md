---
layout: post
title: "바킹독의 실전 알고리즘 : 배열"
categories: [Self-study]
tags: [coding]
last_modified_at: 2026-01-23
---

# 정의와 성질 

배열 : 메모리 상에 원소를 연속하게 배치한 자료구조 

1. O(1)에 k번째 원소 확인 가능 
2. 오버헤드 거의 없음 
3. hit rate 높음 -> CS 확실히 중요하네.. 
4. 연속된 자료구조이기 때문에 할당에 제약이 있다 -> 메모리상에도 연속적 

# 기능과 구현 

```cpp 
#include <bits/stdc++.h>
using namespace std;

void insert(int idx, int num, int arr[], int& len){

}

void erase(int idx, int arr[], int& len){
    
}

void printArr(int arr[], int& len){
  for(int i = 0; i < len; i++) cout << arr[i] << ' ';
  cout << "\n\n";
}

void insert_test(){
  cout << "***** insert_test *****\n";
  int arr[10] = {10, 20, 30};
  int len = 3;
  insert(3, 40, arr, len); // 10 20 30 40
  printArr(arr, len);
  insert(1, 50, arr, len); // 10 50 20 30 40
  printArr(arr, len);
  insert(0, 15, arr, len); // 15 10 50 20 30 40
  printArr(arr, len);
}

void erase_test(){
  cout << "***** erase_test *****\n";
  int arr[10] = {10, 50, 40, 30, 70, 20};
  int len = 6;
  erase(4, arr, len); // 10 50 40 30 20
  printArr(arr, len);
  erase(1, arr, len); // 10 40 30 20
  printArr(arr, len);
  erase(3, arr, len); // 10 40 30
  printArr(arr, len);
}

int main(void) {
  insert_test();
  erase_test();
}
```

# STL vector 

# 연습 문제 