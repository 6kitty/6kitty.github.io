Today I learned : 

# 오늘 할 일 

1. ~~ㅁㅈ님한테 카톡으로 링띤 포스트 보내주기 ㅋㅋ~~
2. ~~아침에 참조 올릴 메일 주소 받고 + 최종본 전달하고~~ 
3. ~~오전에 서류 작성 빨리 끝내기..!~~
3. ~~질문!!! 질문 생각해!!!!!~~
4. BFS 오늘은 해야돼... 더이상 BFS에만 머무를 순 없어... 
5. 퇴근하고 휘낭시에 픽업+피티 + 화과자... 
6. 메신저 보고 적을 건 적기! 
7. ~~퇴근쯤에 컴퓨터 파일들 정리하기!!~~
8. 윈도우 컴으로 메일 제출!!! 

---

## 응용1 - 거리 측정 

2178번 

```cpp
#include <bits/stdc++.h>
using namespace std;
#define X first
#define Y second

string tmp[101];
int board[101][101];

int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};

int main(void){
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++)
        cin>>tmp[i]; //string형 tmp에 다 받기 
    for(int i=0;i<n;i++) fill(board[i],board[i]+m,-1); //board에 다 -1로 채우기 
    queue<pair<int,int>> Q;
    Q.push({0,0}); // 0,0부터 시작 (1,1)에서 출발하는 문제이니까 
    board[0][0]=1; //방문 시작 1칸 

    while(!Q.empty()){
        auto cur=Q.front(); Q.pop();
        for(int dir=0;dir<4;dir++){
            int nx=cur.X+dx[dir];
            int ny=cur.Y+dy[dir];

            if(nx<0||nx>n-1||ny<0||ny>m-1) continue;
            if(board[nx][ny]>0 || tmp[cur.X][cur.Y]!='1') continue; // tmp에서 1이 아니거나 board가 양수칸이거나 

            board[nx][ny]=board[cur.X][cur.Y]+1; //이전 칸의 누적칸 + 1칸 
            Q.push({nx,ny});
        }
    }
    cout<<board[n-1][m-1];
}
```

## 응용2 - 시작점이 여러 개일 때 

7576번 

```cpp 
#include <bits/stdc++.h>
using namespace std;
#define X first
#define Y second

int board[1001][1001];
int vis[1001][1001];

int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};

int main(void){
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n,m;
    queue<pair<int,int>> Q;
    cin >> m >> n;
    for(int i=0;i<n;i++){
        for (int j=0; j<m;j++){
            cin>>board[i][j];
            if(board[i][j]==1) Q.push({i,j});
            if(board[i][j]==0) vis[i][j]=-1;
        }
    }

    while(!Q.empty()){
        auto cur = Q.front(); Q.pop();
        for(int dir=0;dir<4;dir++){
            int nx=cur.X+dx[dir];
            int ny=cur.Y+dy[dir];

            if(nx<0||nx>n-1||ny<0||ny>m-1) continue;
            if(vis[nx][ny]>=0) continue;

            vis[nx][ny]=vis[cur.X][cur.Y]+1;
            Q.push({nx,ny});
        }
    }

    int ans=0;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(vis[i][j]==-1){
                cout<<-1;
                return 0;
            }
            ans=max(ans,vis[i][j]);
        }
    }
    cout<<ans;
}
```

시작점이 여러개일 때는 그냥 while문 돌리기 전에 큐에 시작점들을 다 넣고 시작하면 된다! 

## 응용3 - 시작점이 두 종류일 때 

4179번인데 한 번 고민을 해보래서 좀 그려지는 게 있나 확인해보자. 

```cpp 
#include <bits/stdc++.h>
using namespace std;

#define X first
#define Y second 

int main(void){
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin>>n>>m;

    for(int i=0;i<n;i++){

    }
}

## 응용4 - 1차원에서의 BFS 

---

# 회고 

아 오늘 왜이렇게 졸리냐. 
1. 픽업하고 공릉 픽업하고 
2. 집 가서 메일 보내기 
3. 그리고 할 일 
