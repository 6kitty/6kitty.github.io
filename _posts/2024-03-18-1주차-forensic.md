---
layout: post
title: "[1주차] 시그니처 문제 제작"
categories: [Digital Forensics]
tags: [CRC, Python, Image Processing]
last_modified_at: 2024-03-18
---

1. Check  
풀이 과제 하면서 라업 몇 개 더 참고했었는데 그중에서 좀 흥미로웠던 문제가 하나 있다.  
CRC를 조작할 예정이다.  

![mandu](https://blog.kakaocdn.net/dna/di8DyT/btsFQOyNpGz/AAAAAAAAAAAAAAAAAAAAABvN9oFdkr5Ta5fvxBb_4EsCPg2lQHLHjDU2JGcgKv7Z/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=U5%2BFx2aBAR1gy%2BDmLpzyV0Q0gIg%3D)  

스터디 시간에 썼던 만두를 재탕할 예정이다.  
CRC 4 bytes가 만들어지는 원리는 다음과 같다.  
CRC32 코드를 사용하여 chunk type+data로 검사한다. (chunk length는 제외)  
내가 만들 문제는 chunk length+chunk type+data로 CRC 코드를 만들어줄거다.  

![chunk_structure](https://blog.kakaocdn.net/dna/BEjfH/btsFQRhYh2d/AAAAAAAAAAAAAAAAAAAAAK7ReTYSITx8Dn6qEFisZURXaTDhl6Kc3dDoEqAgxUQJ/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=Ye097rJTDsnTgPPelVVyUAifJKQ%3D)  

해당 청크들 CRC를 모두 바꿔줄 것이다.  

1. 파이썬 크립토 코드가 맞는지 확인  
```python
from zlib import crc32

data = open("mandu.png", 'rb').read()
index = 12  # IHDR chunk가 시작되는 인덱스

chunk = bytearray(data[index:index+17])  # IHDR 시작부터 CRC 전까지의 범위

print(hex(crc32(chunk)))
```

위 파이썬 코드의 결과이다.  

![crc_result](https://blog.kakaocdn.net/dna/mEHxk/btsFQ9Jadry/AAAAAAAAAAAAAAAAAAAAAHrnSG9Z9h9FB8KS8MfLlXeNwRfYoYlIyOYWyRKWUlCq/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=XxHV3KMrkKJIjv1Uf5v5aVUNMxE%3D)  

hxd에 있는 CRC와 동일하다. 맞게 잘 짠 거 같다.  
이제 각 인덱스를 알아야 한다.  

| chunk | length 시작하는 index | CRC index |
|-------|-----------------------|-----------|
| IHDR  | 8                     | 29        |
| IDAT  | 33                    | 8233      |
| IDAT  | 8237                  | 16437     |
| IDAT  | 16441                 | 24641     |
| IEND  | 24645                 | 27627     |

오프셋 말고 인덱스를 이용해서 코드를 다시 짰다.  
```python
from zlib import crc32

data = open("mandu.png", 'rb').read()
index = [8, 33, 8237, 16441, 24645]  # length부터 시작하는 index
endindex = [29, 8233, 16437, 24641, 27627]

for i in range(5):
    chunk = bytearray(data[index[i]:endindex[i]])  # size 
    print(hex(crc32(chunk)))
```

출력된 값은 위와 같다. 이제 HxD를 이용하여 값을 수정하고 저장하면 문제 파일 완성이다.  

![check_image](https://blog.kakaocdn.net/dna/dHOMqd/btsFP9XvCX9/AAAAAAAAAAAAAAAAAAAAACgdJ188weLxOgzOWTEDgVpmi7mcTVG6oQS42DrH8OtD/check.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=XE6GYOksqXsEPOKydwy5bVLR7WU%3D&attach=1&knm=img.png)  

아니 근데 너무 잘 열린다. CRC를 바꿨는데 왜 파일이 잘 열리는걸까  

1-1.  
RACTF 2020에 나온 CRC 문제를 비슷하게 제작해보기로 했다...  

문제 알고리즘은 IHDR 청크의 weight와 height를 맞춰야 하는 문제이다. CRC를 통해 weight, height를 추측하고 png를 바꿔준다.  
문제 파일은 간단하게 IHDR 청크의 weight, height를 00 00 00 00으로 바꾸고 저장하면 된다.  

![ihdr_chunk](https://blog.kakaocdn.net/dna/BcJIf/btsFSbNgKVH/AAAAAAAAAAAAAAAAAAAAAIm8juX-p4sU-QAmiFHxW7cyPQTlUWiRb0MqZmLBivs1/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=SGRaxUBiIMjR%2F959E6vgtN0yGqw%3D)  

이 문제를 풀어보자면..  

![weight_height](https://blog.kakaocdn.net/dna/b1sPoF/btsFP7eisG2/AAAAAAAAAAAAAAAAAAAAAEB5jhDaX6iIpbpdqsWQyonmg1gqdjjLBmPuX-O8uydC/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=1Asc1Nx8uYtDLLWecsed8PwHKec%3D)  

weight와 height가 0이다. 이 값을 알아내기 위해 CRC를 이용해야 한다. 해당 이미지의 CRC는 58 A0 C4 3C 이다. 파이썬 코드로 어떤 값을 crc32로 돌렸을 때 58 A0 C4 3C가 되는 값을 찾아야 한다.  
```python
from zlib import crc32

data = open("size.png", 'rb').read()
index = 12  # IHDR chunk가 시작되는 인덱스

IHDR = bytearray(data[index:index+17])  # IHDR 시작부터 CRC 전까지의 범위
width_index = 7  # width 부분의 세 번째 바이트 인덱스
height_index = 11  # height 부분의 세 번째 바이트 인덱스

for x in range(1, 2000):
    height = bytearray(x.to_bytes(2, 'big'))  # to_bytes(length, byteorder, *, signed=False)
    for y in range(1, 2000):
        width = bytearray(y.to_bytes(2, 'big'))
        for i in range(len(height)):
            IHDR[height_index - i] = height[-i - 1]
        for i in range(len(width)):
            IHDR[width_index - i] = width[-i - 1]
        if hex(crc32(IHDR)) == '0x58a0c43c':  # crc 값
            print("width: 0x{}, height: 0x{}".format(width.hex(), height.hex()))
        for i in range(len(width)):
            IHDR[width_index - i] = bytearray(b'\x00')[0]
```

파이썬 코드를 돌려주면 위 값이 나오는데 이걸  

![insert_value](https://blog.kakaocdn.net/dna/z5Qq5/btsFO0zVmPt/AAAAAAAAAAAAAAAAAAAAABq_hvXy4yOzChbeowEDWO3u8FuNyeJExylHJRJ6aPze/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=sTOuourZUjfnIZk0EArKXOa06o8%3D)  

이 부분에 입력해주면  

![original_image](https://blog.kakaocdn.net/dna/b1ZzFM/btsFSagwyh0/AAAAAAAAAAAAAAAAAAAAADVSOEiOKUahOiMZu9BDdlBnzH-GHzhurH9pUickMaoW/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=ttUF2DZjuVfAurCBNnBI3XXKD2E%3D)  

원래의 이미지가 나온다.  

2. 자바는 꼭 대문자를..  

![java_image](https://blog.kakaocdn.net/dna/dnNPqH/btsFQ9WHe1T/AAAAAAAAAAAAAAAAAAAAAKNnEdjQl30iHd6pqeDnSBgzNHdnGyKXC009ZGMJ7T0h/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=BGC15GYgH8U3toHaLUI%2BcRAXsqM%3D)  

대충 이미지 하나 만들어줬다  

![final_image](https://blog.kakaocdn.net/dna/5OcV3/btsFPGO9qLI/AAAAAAAAAAAAAAAAAAAAAE82tIJdF6HrnNtnf8dPtCxK79wEo7HgX2khVhkiMMAz/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=tIdCteIostW4WfX6RdB5IP3yHj8%3D)  

해당 이미지를 TweakPNG로 열면 chunk 구조를 볼 수 있다.  
gAMA랑 IDAT를 소문자로 바꿔보자.  

![chunk_structure](https://blog.kakaocdn.net/dna/cEvWzN/btsFTckQ4wL/AAAAAAAAAAAAAAAAAAAAAEs2QZlsUbYj6CQSoQ3Is30Z5i7GSaP48nzCQVnGEmHA/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=QEykEyiSoQV3qNBp7QOPgciuza8%3D)  

이러면 문제 파일이 만들어진다.  

![final_output](https://blog.kakaocdn.net/dna/dv8YpK/btsFOZnuOak/AAAAAAAAAAAAAAAAAAAAAKZAmql9NpDnQk0vzhAOstAX5CMQN4ZqfZNIa0wkw7b8/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1769871599&allow_ip=&allow_referer=&signature=eXCcjqDKk6wA2iVcmxoutV%2FGj%2F0%3D)  

저장하고 이미지 파일을 열면 만들었던 이미지가 정상적으로 나온다.